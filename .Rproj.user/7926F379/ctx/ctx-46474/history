##3. Crear un vector con los n?meros consecutivos de los periodos,
##   desde 1 hasta el n?mero de observaciones de la serie
length(licitaciones.ts)
t=c(1:length(licitaciones.ts)) ## se crea variable secuencia, que representa el tiempo, no tiene que ser los a?os
# 4. Ajustar modelo de regresi?n lineal
modelo1<-lm(licitaciones.ts~t) ## no es necesario modelar el tiempo de la serie si no una secuencia
# 5. Ver resumen y verificar si el modelo es significativo, y si tiene un buen ajuste con el R cuadrado
summary(modelo1)
licita_ts_train=window(licitaciones.ts,start=1990, end =2015) #Muestra para entrenamiento 80% de los datos
# 5. Ver resumen y verificar si el modelo es significativo, y si tiene un buen ajuste con el R cuadrado
summary(modelo1)
licita_ts_train=window(licitaciones.ts,start=1990, end =2015) #Muestra para entrenamiento 80% de los datos
licita_ts_test=window(licitaciones.ts, start=2015) ## muestra para evaluaci?n
t_train=c(1:101)  ## se crean nuevos vectores con la secuencia de periodos para entrenamiento y evaluaci?n
t_test=c(102:129)
### verificar que la separaci?n de la serie y la creaci?n de los vectores de tiempo queden bien
length(licita_ts_train)
length(t_train)
print(licita_ts_train)
length(licita_ts_test)
length(t_test)
print(licita_ts_test)
### 4 Se crean formatos data.frame para entrenamiento y predicci?n
### el nombre de la columna tiempo en ambos data frame debe ser igual, sino la predicci?n presente problema
data_train=data.frame(licita_ts_train,"t"=t_train, "t2"=t_train^2) ## los datos de entrenamiento necesitan variable respuesta
data_test=data.frame("t"=t_test, "t2"=t_test^2) ## Para hacer predicciones no se necesitan variable respuesta, se utiliza la ecuaci?n del modelo anterior para predecir
### 5. Se entrena modelo en datos de entrenamiento, entrenar dos para comparar
modelo1=lm(licita_ts_train~t,data=data_train) ## entrenar/ajustar modelo
modelo2=lm(licita_ts_train~t2,data=data_train)
## 6. Se realiza predicci?n/pron?stico en datos de entrenamiento usando el modelo creado en el paso anterior
pred_train=predict(modelo1)
pred_train=modelo1$fitted.values ## hace lo mismo que la funci?n anterior, predicci?n de los datos de entrenamiento
pred_train2=predict(modelo2)
pred_train2=modelo2$fitted.values ## hace lo mismo que la funci?n anterior, predicci?n de los datos de entrenamiento
## 7. Se realiza predicci?n en datos nuevos (evaluaci?n)
pred_test=predict(modelo1,newdata=data_test) ## hacer pronosticos para una base diferente a entrenamiento
pred_test2=predict(modelo2,newdata=data_test) ## hacer pronosticos para una base diferente a entrenamiento
forecast::accuracy(modelo1)
forecast::accuracy(modelo2)
print("mape Train")
Metrics::mape(licita_ts_train,pred_train)
Metrics::mape(licita_ts_train,pred_train2)
print("mape Test")
Metrics::mape(licita_ts_test,pred_test)
Metrics::mape(licita_ts_test,pred_test2)
print("AIC de los modelos")
AIC(modelo1)
AIC(modelo2)
print("BIC de los modelos")
BIC(modelo1)
BIC(modelo2)
length(licitaciones.ts)
licita1=licitaciones.ts[-32] ## a la primera serie se elimina la ?ltima fila
licita2=licitaciones.ts[-1]
data.frame(licita1,licita2)
## Gr?ficamente
plot(licita1,licita2)
##Medida de correlaci?n
cor(licita1,licita2)
dwtest(licita1~licita2)
acf(licitaciones.ts)
dwtest(licita1~licita2)
acf(licitaciones.ts)
acf(licitaciones.ts,plot=F)
pacf(licitaciones.ts)
pacf(licitaciones.ts,plot=F)
ma_licita=sma(y=licitaciones.ts,h=9,silent = F,interval=T, level=0.95) ## se ajusta un modelo de medias m?viles
class(ma_licita)
library(tseries)
library(lubridate)
library(tseries)
library(lubridate)
library(tidyverse)
library(car)
library(astsa)
library(foreign)
library(timsac)
library(vars)
library(lmtest)
library(mFilter)
library(dynlm)
library(nlme)
library(lmtest)
library(broom)
library(kableExtra)
library(knitr)
library(MASS)
library(parallel)
library(car)
library(mlogit)
library(dplyr)
library(tidyr)
library(forecast)
library(fpp2)
library(fpp)
library(stats)
library(quantmod)
library(Metrics)
library(smooth)
length(licitaciones.ts)
licita1=licitaciones.ts[-32] ## a la primera serie se elimina la ?ltima fila
licita2=licitaciones.ts[-1]
data.frame(licita1,licita2)
## Gr?ficamente
plot(licita1,licita2)
##Medida de correlaci?n
cor(licita1,licita2)
dwtest(licita1~licita2)
acf(licitaciones.ts)
acf(licitaciones.ts,plot=F)
pacf(licitaciones.ts)
pacf(licitaciones.ts,plot=F)
ma_licita=sma(y=licitaciones.ts,h=9,silent = F,interval=T, level=0.95) ## se ajusta un modelo de medias m?viles
class(ma_licita)
summary(ma_licita)
ma_licita$residuals
library(smooth)
install.packages("smooth")
install.packages("smooth")
library(smooth)
licitaciones=read.csv("licitaciones.csv")
attach(licitaciones)
names(licitaciones)
#AJUSTAR EL MODELO
##1. Pasar la serie de tiempo a formato ts(timeseries object)
licitaciones.ts=ts(licitaciones, start=c(1990,1), frequency = 4)
print(licitaciones.ts)
class(licitaciones.ts)
start(licitaciones.ts)
end(licitaciones.ts)
## 2. Gr?ficar
plot(licitaciones.ts,  main="Indice de contratos adjudicados desde 1990 hasta 2021", ylab="Licitaciones", col="blue")
##3. Crear un vector con los n?meros consecutivos de los periodos,
##   desde 1 hasta el n?mero de observaciones de la serie
length(licitaciones.ts)
t=c(1:length(licitaciones.ts)) ## se crea variable secuencia, que representa el tiempo, no tiene que ser los a?os
## este vector servir? como variable explicativa
# 4. Ajustar modelo de regresi?n lineal
modelo1<-lm(licitaciones.ts~t) ## no es necesario modelar el tiempo de la serie si no una secuencia
# 5. Ver resumen y verificar si el modelo es significativo, y si tiene un buen ajuste con el R cuadrado
summary(modelo1)
#MAPE
### 2. separar la serie de tiempo 80-20 para entrenamiento y evaluaci?n
licita_ts_train=window(licitaciones.ts,start=1990, end =2015) #Muestra para entrenamiento 80% de los datos
licita_ts_test=window(licitaciones.ts, start=2015) ## muestra para evaluaci?n
### 3. Se crean los vectores de los tiempos y los data_frame de entrenamiento y prueba para no tener problema con el formato de la tabla
t_train=c(1:101)  ## se crean nuevos vectores con la secuencia de periodos para entrenamiento y evaluaci?n
t_test=c(102:129)
### verificar que la separaci?n de la serie y la creaci?n de los vectores de tiempo queden bien
length(licita_ts_train)
length(t_train)
print(licita_ts_train)
length(licita_ts_test)
length(t_test)
print(licita_ts_test)
### 4 Se crean formatos data.frame para entrenamiento y predicci?n
### el nombre de la columna tiempo en ambos data frame debe ser igual, sino la predicci?n presente problema
data_train=data.frame(licita_ts_train,"t"=t_train, "t2"=t_train^2) ## los datos de entrenamiento necesitan variable respuesta
data_test=data.frame("t"=t_test, "t2"=t_test^2) ## Para hacer predicciones no se necesitan variable respuesta, se utiliza la ecuaci?n del modelo anterior para predecir
### 5. Se entrena modelo en datos de entrenamiento, entrenar dos para comparar
modelo1=lm(licita_ts_train~t,data=data_train) ## entrenar/ajustar modelo
modelo2=lm(licita_ts_train~t2,data=data_train)
## 6. Se realiza predicci?n/pron?stico en datos de entrenamiento usando el modelo creado en el paso anterior
pred_train=predict(modelo1)
pred_train=modelo1$fitted.values ## hace lo mismo que la funci?n anterior, predicci?n de los datos de entrenamiento
pred_train2=predict(modelo2)
pred_train2=modelo2$fitted.values ## hace lo mismo que la funci?n anterior, predicci?n de los datos de entrenamiento
## 7. Se realiza predicci?n en datos nuevos (evaluaci?n)
pred_test=predict(modelo1,newdata=data_test) ## hacer pronosticos para una base diferente a entrenamiento
pred_test2=predict(modelo2,newdata=data_test) ## hacer pronosticos para una base diferente a entrenamiento
## 8. Se calcula el mape de los datos reales de entrenamiento vs los predichos de entrenamiento
forecast::accuracy(modelo1)
forecast::accuracy(modelo2)
## el mape en esta funci?n est? en porcentaje
## cuando se aplica la funci?n accuracy s?lo con el modelo se calculans las funciones de perdida para los datos de entrenamiento
print("mape Train")
Metrics::mape(licita_ts_train,pred_train)
Metrics::mape(licita_ts_train,pred_train2)
### en de esta funci?n el mape no est? en porcentaje sino en proporci?n
## la funciones de metrics no utilizan el modelo, sino los vectores de predichos y de reales
## 9. Se calcula el mape de los datos reales de evaluaci?n vs los predichos de evaluaci?n
print("mape Test")
Metrics::mape(licita_ts_test,pred_test)
Metrics::mape(licita_ts_test,pred_test2)
### el de esta funci?n el mape no est? en porcentaje sino en proporci?n
## la funciones de metrics no utilizan el modelo, sino los vectores de predichos y de reales
## 10. comparar AIC y BIC s?lo se calcula para el modelo, no por muestras
## comparaci?n de modelos con AIC y BIC
print("AIC de los modelos")
AIC(modelo1)
AIC(modelo2)
print("BIC de los modelos")
BIC(modelo1)
BIC(modelo2)
#Autocorrelaci?n
length(licitaciones.ts)
licita1=licitaciones.ts[-32] ## a la primera serie se elimina la ?ltima fila
licita2=licitaciones.ts[-1]
data.frame(licita1,licita2)
### analizar correlaci?n en serie - rezago de 1
## Gr?ficamente
plot(licita1,licita2)
##Medida de correlaci?n
cor(licita1,licita2)
##Prueba de durbinwatson
dwtest(licita1~licita2)
acf(licitaciones.ts)
acf(licitaciones.ts,plot=F)
pacf(licitaciones.ts)
pacf(licitaciones.ts,plot=F)
#pacf(rnorm(100))
#acf(rnorm(100))
##Medias moviles
ma_licita=sma(y=licitaciones.ts,h=9,silent = F,interval=T, level=0.95) ## se ajusta un modelo de medias m?viles
class(ma_licita)
summary(ma_licita)
ma_licita$residuals
ma_licita$fitted
datos_pronosticos=data.frame('pronostico'=ma_licita$forecast,'superior'=ma_licita$upper,'inferior'=ma_licita$lower )
datos_ajuste=data.frame(ma_licita$y,ma_licita$fitted,ma_licita$residuals)
colnames(datos_ajuste)=c("real","ajuste","residuo") ## esta funci?n asinga nombres a las columnas de dataframe
head(datos_pronosticos)
head(datos_ajuste)  #La funci?n head muestra las primeras filas de una tabla
#Ajuste con diferentes ventanas:
ma_licita2=sma(y=licitaciones.ts,order=12,h=9, silent = F,interval=T, level=0.90)
ma_licita2
summary(ma_licita2)
df=data.frame("original"=licitaciones.ts,"ma_order_8"=ma_licita2$fitted,"ma_order_4"=ma_licita$fitted)
df
write.csv(df,"licitaciones.csv")
write.table(df)
#Suavizamiento exponencial simple
ses_licita<-ses(licitaciones.ts, h=9)
summary(ses_licita)
plot(ses_licita)
ses_licita$fitted
#Suavizamiento exponencial Holt
modelo_holt <- holt(licitaciones.ts) ### s?lo con la funci?n y el nombre de la serie se obtiene un modelo, es la forma m?s sencilla
plot(modelo_holt)
summary(modelo_holt)
#Con argumentos
modelo_holt1 <- holt(licitaciones.ts, h=9,initial="simple", exponential=T) ### s?lo con la funci?n y el nombre de la serie se obtiene un modelo, es la forma m?s sencilla
plot(modelo_holt1)
summary(modelo_holt1)
#Suavizamiento exponencial de Holt-Winters:
licitaciones.ts1=ts(licitaciones.ts, start=c(1990,1), frequency = 4)
fit1 <- hw(licitaciones.ts1)
model_hw <- hw(licitaciones.ts1,h=15,seasonal="multiplicative")
summary(fit1)
summary(model_hw)
plot(fit1)
plot(model_hw)
ajustado=model_hw$fitted
real=model_hw$x
mape(real,ajustado)
hw_f<-function(x,h){forecast(hw(x,h))
}
e=tsCV(licitaciones.ts,hw_f,h=9)
e
erroresh1<-e[29:48,1]
erroresh2<-e[29:48,2]
erroresh3<-e[29:48,3]
erroresh10<-e[29:48,9]
mapeh1=mean(abs(erroresh1/ausair[29:48]),na.rm=T)
mapeh2=mean(abs(erroresh2/ausair[29:48]),na.rm=T)
mapeh3=mean(abs(erroresh3/ausair[29:48]),na.rm=T)
mapeh10=mean(abs(erroresh10/ausair[29:48]),na.rm=T)
mapeh1
mapeh2
mapeh3
mapeh10
#Ajustar medias moviles
sma_model=sma(licitaciones.ts,h=9, order=8,silent=F,interval=T)
sma_model
sma_model$forecast
### Mape de entrenamiento 1 periodo
ajustado=sma_model$fitted
real=licitaciones.ts
mape(real,ajustado)
### Para mape de evaluaci?n h periodos de pron?stico
sma_f<-function(x,h){  ### se debe crear funci?n con la funci?n de pron?stico y los argumentos que se quieran utilizar
forecast(sma(x,h,order=8))
}
e=tsCV(licitaciones.ts,sma_f,h=10)  ### esta funci?n permite hacer el calculo de varios pron?sticos de un mismo h al mismo tiempo
e
erroresh1<-e[29:48,1]
erroresh2<-e[29:48,2]
erroresh3<-e[29:48,3]
erroresh10<-e[29:48,10]
mapeh1=mean(abs(erroresh1/ausair[29:48]),na.rm=T)
mapeh2=mean(abs(erroresh2/ausair[29:48]),na.rm=T)
mapeh3=mean(abs(erroresh3/ausair[29:48]),na.rm=T)
mapeh10=mean(abs(erroresh10/ausair[29:48]),na.rm=T)
mapeh1
mapeh2
mapeh3
mapeh10
##Ajustar suavizamiento exponencial simple
ses_model=ses(licitaciones.ts,h=9)
summary(ses_model)
plot(ses_model)
## MAPE Entrenamiento 1 periodo
ajustado=ses_model$fitted
real=ses_model$x
mape(real,ajustado) ## debe coincidir con salidad del modelo
ses_f<-function(x,h){
forecast(ses(x,h,alpha=0.62))
}
e=tsCV(licitaciones.ts,ses_f,h=15)
e
erroresh1<-e[29:48,1]
erroresh2<-e[29:48,2]
erroresh3<-e[29:48,3]
erroresh10<-e[29:48,10]
mapeh1=mean(abs(erroresh1/ausair[29:48]),na.rm=T)
mapeh2=mean(abs(erroresh2/ausair[29:48]),na.rm=T)
mapeh3=mean(abs(erroresh3/ausair[29:48]),na.rm=T)
mapeh10=mean(abs(erroresh10/ausair[29:48]),na.rm=T)
mapeh1
mapeh2
mapeh3
mapeh10
hist(e[,10])
#Ajustar Suavizamiento exponencial de holt
holt_model=holt(licitaciones.ts,h=9)
summary(holt_model)
plot(holt_model)
## MAPE Entrenamiento 1 periodo
ajustado=holt_model$fitted
real=holt_model$x
mape(real,ajustado)
###Mape evaluaci?n m?s de 1 periodo
holt_f<-function(x,h){
forecast(holt(x,h))
}
e=tsCV(licitaciones.ts,holt_f,h=15)
e
erroresh1<-e[29:48,1]
erroresh2<-e[29:48,2]
erroresh3<-e[29:48,3]
erroresh10<-e[29:48,10]
mapeh1=mean(abs(erroresh1/ausair[29:48]),na.rm=T)
mapeh2=mean(abs(erroresh2/ausair[29:48]),na.rm=T)
mapeh3=mean(abs(erroresh3/ausair[29:48]),na.rm=T)
mapeh10=mean(abs(erroresh10/ausair[29:48]),na.rm=T)
mapeh1
mapeh2
mapeh3
mapeh10
#Ajustar Suavizamiento exponencial de Holt-Winters
hw_model=hw(licitaciones.ts,h=9,seasonal="multiplicative")
summary(hw_model)
plot(hw_model)
## MAPE Entrenamiento 1 periodo
ajustado=hw_model$fitted
real=hw_model$x
mape(real,ajustado)
###Mape evaluaci?n
hw_f<-function(x,h){
forecast(hw(x,h))
}
e=tsCV(licitaciones.ts,hw_f,h=9)
e
erroresh1<-e[29:48,1]
erroresh2<-e[29:48,2]
erroresh3<-e[29:48,3]
erroresh10<-e[29:48,9]
mapeh1=mean(abs(erroresh1/ausair[29:48]),na.rm=T)
mapeh2=mean(abs(erroresh2/ausair[29:48]),na.rm=T)
mapeh3=mean(abs(erroresh3/ausair[29:48]),na.rm=T)
mapeh10=mean(abs(erroresh10/ausair[29:48]),na.rm=T)
mapeh1
mapeh2
mapeh3
mapeh10
print("AIC de los modelos")
AIC(modelo1)
AIC(modelo2)
print("BIC de los modelos")
BIC(modelo1)
BIC(modelo2)
length(licitaciones.ts)
licita1=licitaciones.ts[-32] ## a la primera serie se elimina la ?ltima fila
licita2=licitaciones.ts[-1]
data.frame(licita1,licita2)
## Gr?ficamente
plot(licita1,licita2)
##Medida de correlaci?n
cor(licita1,licita2)
dwtest(licita1~licita2)
library(lubridate)
library(tseries)
library(lubridate)
library(tidyverse)
library(car)
library(astsa)
library(foreign)
library(timsac)
library(vars)
library(lmtest)
library(mFilter)
library(dynlm)
library(nlme)
library(lmtest)
library(broom)
library(kableExtra)
library(knitr)
library(MASS)
library(parallel)
library(car)
library(mlogit)
library(dplyr)
library(tidyr)
library(forecast)
library(fpp2)
library(fpp)
library(stats)
library(quantmod)
library(Metrics)
library(smooth)
ma_licita=sma(y=licitaciones.ts,h=9,silent = F,interval=T, level=0.95) ## se ajusta un modelo de medias m?viles
class(ma_licita)
summary(ma_licita)
ma_licita$residuals
library(smooth)
install.packages("greybox")
library(smooth)
library(greybox)
install.packages("generics")
install.packages("generics")
library(generics)
library(greybox)
dwtest(licita1~licita2)
library(lmtest)
ma_licita=sma(y=licitaciones.ts,h=9,silent = F,interval=T, level=0.95) ## se ajusta un modelo de medias m?viles
##Medias moviles
library(smooth)
ma_licita=sma(y=licitaciones.ts,h=9,silent = F,interval=T, level=0.95) ## se ajusta un modelo de medias m?viles
class(ma_licita)
summary(ma_licita)
ma_licita$residuals
ma_licita$fitted
datos_pronosticos=data.frame('pronostico'=ma_licita$forecast,'superior'=ma_licita$upper,'inferior'=ma_licita$lower )
datos_ajuste=data.frame(ma_licita$y,ma_licita$fitted,ma_licita$residuals)
colnames(datos_ajuste)=c("real","ajuste","residuo") ## esta funci?n asinga nombres a las columnas de dataframe
head(datos_pronosticos)
dwtest(licita1~licita2)
datos_ajuste=data.frame(ma_licita$y,ma_licita$fitted,ma_licita$residuals)
colnames(datos_ajuste)=c("real","ajuste","residuo") ## esta funci?n asinga nombres a las columnas de dataframe
head(datos_pronosticos)
head(datos_ajuste)  #La funci?n head muestra las primeras filas de una tabla
ma_licita2=sma(y=licitaciones.ts,order=12,h=9, silent = F,interval=T, level=0.90)
ma_licita2
summary(ma_licita2)
df=data.frame("original"=licitaciones.ts,"ma_order_8"=ma_licita2$fitted,"ma_order_4"=ma_licita$fitted)
df
write.csv(df,"licitaciones.csv")
write.table(df)
ses_licita<-ses(licitaciones.ts, h=9)
summary(ses_licita)
plot(ses_licita)
ses_licita$fitted
modelo_holt <- holt(licitaciones.ts) ### s?lo con la funci?n y el nombre de la serie se obtiene un modelo, es la forma m?s sencilla
ses_licita<-ses(licitaciones.ts, h=9)
#Suavizamiento exponencial simple
library(forecast)
ses_licita<-ses(licitaciones.ts, h=9)
summary(ses_licita)
library(forecast)
datos_pronosticos=data.frame('pronostico'=ma_licita$forecast,'superior'=ma_licita$upper,'inferior'=ma_licita$lower )
datos_ajuste=data.frame(ma_licita$y,ma_licita$fitted,ma_licita$residuals)
colnames(datos_ajuste)=c("real","ajuste","residuo") ## esta funci?n asinga nombres a las columnas de dataframe
head(datos_pronosticos)
head(datos_ajuste)  #La funci?n head muestra las primeras filas de una tabla
ma_licita2=sma(y=licitaciones.ts,order=12,h=9, silent = F,interval=T, level=0.90)
ma_licita2
summary(ma_licita2)
df=data.frame("original"=licitaciones.ts,"ma_order_8"=ma_licita2$fitted,"ma_order_4"=ma_licita$fitted)
df
write.csv(df,"licitaciones.csv")
write.table(df)
#Suavizamiento exponencial simple
library(forecast)
ses_licita<-ses(licitaciones.ts, h=9)
summary(ses_licita)
plot(ses_licita)
ses_licita$fitted
modelo_holt <- holt(licitaciones.ts) ### s?lo con la funci?n y el nombre de la serie se obtiene un modelo, es la forma m?s sencilla
plot(modelo_holt)
summary(modelo_holt)
modelo_holt1 <- holt(licitaciones.ts, h=9,initial="simple", exponential=T) ### s?lo con la funci?n y el nombre de la serie se obtiene un modelo, es la forma m?s sencilla
plot(modelo_holt1)
summary(modelo_holt1)
licitaciones.ts1=ts(licitaciones.ts, start=c(1990,1), frequency = 4)
fit1 <- hw(licitaciones.ts1)
model_hw <- hw(licitaciones.ts1,h=15,seasonal="multiplicative")
summary(fit1)
summary(model_hw)
plot(fit1)
#Ruta de lectura del archivo:
library(readr)
datos <- read_csv("Muestreo y Series de Tiempo/TALLER 1 MUESTREO Y SERIES DE TIEMPO/datos.csv")
datos <- read_csv("datos.csv")
View(datos)
#Istalamos paquetes:
install.packages("Mcomp")
install.packages("smooth")
install.packages("tseries")
install.packages("Metrics")
install.packages("forecast")
#Llamamos librerias:
library(Mcomp)
